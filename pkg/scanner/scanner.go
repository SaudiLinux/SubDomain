package scanner

import (
	"bufio"
	"fmt"
	"net"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/fatih/color"
)

// Config holds the scanner configuration
type Config struct {
	Target     string
	Wordlist   string
	Threads    int
	OutputFile string
	Verbose    bool
}

// Result represents a scan result
type Result struct {
	Subdomain string
	IP        string
	Found     bool
}

// Scanner represents the subdomain scanner
type Scanner struct {
	config     Config
	results    []Result
	wordlist   []string
	resultChan chan Result
	wg         sync.WaitGroup
	mutex      sync.Mutex
}

// NewScanner creates a new scanner instance
func NewScanner(config Config) *Scanner {
	return &Scanner{
		config:     config,
		results:    []Result{},
		resultChan: make(chan Result),
	}
}

// Start begins the scanning process
func (s *Scanner) Start() {
	// Load wordlist
	err := s.loadWordlist()
	if err != nil {
		fmt.Printf("\033[1;31m[!] Error: %v\033[0m\n", err)
		os.Exit(1)
	}

	fmt.Printf("\033[1;34m[*] Target: %s\033[0m\n", s.config.Target)
	fmt.Printf("\033[1;34m[*] Wordlist: %s (%d entries)\033[0m\n", s.config.Wordlist, len(s.wordlist))
	fmt.Printf("\033[1;34m[*] Threads: %d\033[0m\n", s.config.Threads)
	fmt.Println("\033[1;34m[*] Starting scan...\033[0m")

	// Start time
	startTime := time.Now()

	// Start result collector
	go s.collectResults()

	// Create worker pool
	jobs := make(chan string, len(s.wordlist))

	// Start workers
	for i := 0; i < s.config.Threads; i++ {
		go s.worker(jobs)
	}

	// Send jobs to workers
	for _, word := range s.wordlist {
		jobs <- word
	}
	close(jobs)

	// Wait for all workers to finish
	s.wg.Wait()
	close(s.resultChan)

	// Calculate elapsed time
	elapsedTime := time.Since(startTime)

	// Print summary
	fmt.Println("\n\033[1;32m[+] Scan completed!\033[0m")
	fmt.Printf("\033[1;32m[+] Found %d subdomains in %s\033[0m\n", s.countFoundSubdomains(), elapsedTime)

	// Save results to file if specified
	if s.config.OutputFile != "" {
		s.saveResults()
	}
}

// loadWordlist loads the wordlist from file
func (s *Scanner) loadWordlist() error {
	file, err := os.Open(s.config.Wordlist)
	if err != nil {
		return fmt.Errorf("failed to open wordlist file: %v", err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		word := strings.TrimSpace(scanner.Text())
		if word != "" && !strings.HasPrefix(word, "#") {
			s.wordlist = append(s.wordlist, word)
		}
	}

	if err := scanner.Err(); err != nil {
		return fmt.Errorf("error reading wordlist: %v", err)
	}

	return nil
}

// worker processes subdomain checks
func (s *Scanner) worker(jobs <-chan string) {
	for word := range jobs {
		s.wg.Add(1)
		subdomain := fmt.Sprintf("%s.%s", word, s.config.Target)
		s.checkSubdomain(subdomain)
	}
}

// checkSubdomain checks if a subdomain exists
func (s *Scanner) checkSubdomain(subdomain string) {
	defer s.wg.Done()

	result := Result{
		Subdomain: subdomain,
		Found:     false,
	}

	ips, err := net.LookupIP(subdomain)
	if err == nil && len(ips) > 0 {
		result.Found = true
		result.IP = ips[0].String()
	}

	s.resultChan <- result
}

// collectResults collects and processes scan results
func (s *Scanner) collectResults() {
	for result := range s.resultChan {
		s.mutex.Lock()
		s.results = append(s.results, result)
		s.mutex.Unlock()

		if result.Found {
			green := color.New(color.FgGreen).SprintFunc()
			fmt.Printf("%s %s -> %s\n", green("[+]"), result.Subdomain, result.IP)
		} else if s.config.Verbose {
			red := color.New(color.FgRed).SprintFunc()
			fmt.Printf("%s %s\n", red("[-]"), result.Subdomain)
		}
	}
}

// countFoundSubdomains counts the number of found subdomains
func (s *Scanner) countFoundSubdomains() int {
	count := 0
	for _, result := range s.results {
		if result.Found {
			count++
		}
	}
	return count
}

// saveResults saves the scan results to a file
func (s *Scanner) saveResults() {
	file, err := os.Create(s.config.OutputFile)
	if err != nil {
		fmt.Printf("\033[1;31m[!] Error: Failed to create output file: %v\033[0m\n", err)
		return
	}
	defer file.Close()

	writer := bufio.NewWriter(file)
	writer.WriteString(fmt.Sprintf("# Sub Domain Scan Results for %s\n", s.config.Target))
	writer.WriteString(fmt.Sprintf("# Generated by Sub Tool - By SayerLinux (SaudiSayer@gmail.com)\n"))
	writer.WriteString(fmt.Sprintf("# Date: %s\n\n", time.Now().Format(time.RFC1123)))

	for _, result := range s.results {
		if result.Found {
			writer.WriteString(fmt.Sprintf("%s,%s\n", result.Subdomain, result.IP))
		}
	}

	writer.Flush()
	fmt.Printf("\033[1;32m[+] Results saved to %s\033[0m\n", s.config.OutputFile)
}